// Code generated by gnorm, DO NOT EDIT!

package authors

import (
	"context"

	"github.com/Mattel/mcpp/data/gnorm"
	"github.com/gnormal/postgres-go/generated"
	uuid "github.com/gofrs/uuid"
	"github.com/pkg/errors"
)

// TableName is the primary table that this particular gnormed file deals with.
const TableName = "authors"

// Row represents a row from 'authors'.
type Row struct {
	ID   uuid.UUID // id (PK)
	Name string    // name
}

// Field values for every column in Authors.
var (
	IDCol   generated.UuidUUIDField = "id"
	NameCol generated.StringField   = "name"
)

// All retrieves all rows from 'authors' as a slice of Row.
func All(ctx context.Context, db generated.DB) ([]*Row, error) {
	const sqlstr = `SELECT
		id, name
		FROM public.authors`

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, errors.Wrap(err, "query Authors")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.ID,
			&r.Name,
		)
		if err != nil {
			return nil, errors.Wrap(err, "all Authors")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// CountQuery retrieve one row from 'authors'.
func CountQuery(ctx context.Context, db gnorm.DB, where gnorm.WhereClause) (int, error) {
	const origsqlstr = `SELECT
		count(*) as count
		FROM public.authors WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	count := 0
	err := db.QueryRowContext(ctx, sqlstr, where.Values()...).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "count Authors")
	}
	return count, nil
}

// Query retrieves rows from 'authors' as a slice of Row.
func Query(ctx context.Context, db generated.DB, where generated.WhereClause) ([]*Row, error) {
	const origsqlstr = `SELECT
		id, name
		FROM public.authors WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr, where.Values()...)
	if err != nil {
		return nil, errors.Wrap(err, "query Authors")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.ID,
			&r.Name,
		)
		if err != nil {
			return nil, errors.Wrap(err, "query Authors")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// QueryOrder retrieves rows from 'authors' as a slice of Row in a particular order.
func QueryOrder(ctx context.Context, db generated.DB, where generated.WhereClause, orderby generated.OrderBy) ([]*Row, error) {
	const origsqlstr = `SELECT
		id, name
		FROM public.authors WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + orderby.String()

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr, where.Values()...)
	if err != nil {
		return nil, errors.Wrap(err, "query Authors")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.ID,
			&r.Name,
		)
		if err != nil {
			return nil, errors.Wrap(err, "query Authors")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// One retrieve one row from 'authors'.
func One(ctx context.Context, db generated.DB, where generated.WhereClause) (*Row, error) {
	const origsqlstr = `SELECT
		id, name
		FROM public.authors WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	r := &Row{}
	err := db.QueryRowContext(ctx, sqlstr, where.Values()...).Scan(&r.ID,
		&r.Name,
	)
	if err != nil {
		return nil, errors.Wrap(err, "queryOne Authors")
	}
	return r, nil
}

// First retrieve one row from 'authors' when sorted by orderby.
func First(ctx context.Context, db generated.DB, where generated.WhereClause, orderby generated.OrderBy) (*Row, error) {
	const origsqlstr = `SELECT
		id, name
		FROM public.authors WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + orderby.String()

	r := &Row{}
	err := db.QueryRowContext(ctx, sqlstr, where.Values()...).Scan(&r.ID,
		&r.Name,
	)
	if err != nil {
		return nil, errors.Wrap(err, "queryFirst Authors")
	}
	return r, nil
}

// Find retrieves a row from 'authors' by its primary key(s).
func Find(ctx context.Context, db generated.DB,
	id uuid.UUID,
) (*Row, error) {
	const sqlstr = `SELECT
		id, name
	FROM public.authors WHERE ( id = $1 )`

	r := &Row{}
	err := db.QueryRowContext(ctx, sqlstr,
		id,
	).Scan(&r.ID,
		&r.Name,
	)
	if err != nil {
		return nil, errors.Wrap(err, "find Authors")
	}
	return r, nil
}

// Insert inserts the row into the database.
func Insert(ctx context.Context, db generated.DB, r *Row) error {
	const sqlstr = `INSERT INTO public.authors ` +
		`(
			name
		) VALUES (
			$1
		) ` +
		`RETURNING
			created_at, id
		`

	err := db.QueryRowContext(ctx, sqlstr, &r.Name).Scan(&r.CreatedAt, &r.ID)

	return errors.Wrap(err, "insert Authors")
}

// InsertIgnore inserts the row into the database but ignores conflicts
func InsertIgnore(ctx context.Context, db gnorm.DB, r *Row, constraint string) error {
	sqlstr := `INSERT INTO public.authors ` +
		`(
			name
		) VALUES (
			$1
		) ` +
		`ON CONFLICT ON CONSTRAINT ` + constraint + ` DO NOTHING `
	_, err := db.ExecContext(ctx, sqlstr, r.Name)
	return errors.Wrap(err, "insert ignore Authors")
}

// Set sets a single column on an existing row in the database.
func Set(ctx context.Context, db generated.DB, set generated.Where, where generated.WhereClause) (int64, error) {
	idx := 2
	sqlstr := `UPDATE public.authors SET ` +
		set.Field + " = $1 " +
		` WHERE ` +
		where.String(&idx)

	res, err := db.ExecContext(ctx, sqlstr, append([]interface{}{set.Value}, where.Values()...)...)
	if err != nil {
		return 0, errors.Wrap(err, "set Authors")
	}
	return res.RowsAffected()
}

// AppendInt64 adds a value to a field
func AppendInt64(ctx context.Context, db generated.DB, name string, value interface{}, where generated.WhereClause) (int64, error) {
	idx := 2
	sqlstr := `UPDATE public.authors SET ` +
		name + " = array_append(" + name + ", $1::bigint) " +
		` WHERE ` +
		where.String(&idx)

	res, err := db.ExecContext(ctx, sqlstr, append([]interface{}{value}, where.Values()...)...)
	if err != nil {
		return 0, errors.Wrap(err, "append_int64 Authors")
	}
	return res.RowsAffected()
}

// Inc increments the value of a single column on an existing row in the database.
func Inc(ctx context.Context, db generated.DB, inc generated.Where, where generated.WhereClause) (int64, error) {
	idx := 2
	sqlstr := `UPDATE public.authors SET ` +
		inc.Field + " = " + inc.Field + " + $1" +
		` WHERE ` +
		where.String(&idx)

	res, err := db.ExecContext(ctx, sqlstr, append([]interface{}{inc.Value}, where.Values()...)...)
	if err != nil {
		return 0, errors.Wrap(err, "inc Authors")
	}
	return res.RowsAffected()
}

// Upsert performs an insert-or-update in one DB call for Authors.
// Unlike insert, upsert requires that you have set any IDs on the row you're upserting.
// NOTE: PostgreSQL 9.5+ only
func Upsert(ctx context.Context, db generated.DB, r *Row) error {

	const sqlstr = `INSERT INTO public.authors (
		id, name
	) VALUES (
		$1, $2
	) ON CONFLICT (id) DO UPDATE SET (
		id, name
	) = (
		$1, $2
	)`

	_, err := db.ExecContext(ctx, sqlstr, r.ID, r.Name)
	return errors.Wrap(err, "upsert Authors")
}

// Delete deletes the Row from the database. Returns the number of items deleted.
func Delete(ctx context.Context,
	db generated.DB,
	id uuid.UUID,
) (int64, error) {
	const sqlstr = `DELETE FROM public.authors 
	WHERE
	  id = $1
	`

	res, err := db.ExecContext(ctx, sqlstr, id)
	if err != nil {
		return 0, errors.Wrap(err, "delete Authors")
	}
	rows, err := res.RowsAffected()
	if err != nil {
		return 0, err
	}
	return rows, nil
}

// DeleteWhere deletes Rows from the database and returns the number of rows deleted.
func DeleteWhere(ctx context.Context, db generated.DB, where generated.WhereClause) (int64, error) {
	const origsqlstr = `DELETE FROM public.authors WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	res, err := db.ExecContext(ctx, sqlstr, where.Values()...)
	if err != nil {
		return 0, errors.Wrap(err, "delete Authors")
	}
	return res.RowsAffected()
}

// DeleteAll deletes all Rows from the database and returns the number of rows deleted.
func DeleteAll(ctx context.Context, db generated.DB) (int64, error) {
	const sqlstr = `DELETE FROM public.authors`

	res, err := db.ExecContext(ctx, sqlstr)
	if err != nil {
		return 0, errors.Wrap(err, "deleteall Authors")
	}
	return res.RowsAffected()
}
